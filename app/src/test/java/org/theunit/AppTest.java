/*
 * This source file was generated by the Gradle 'init' task
 */
package org.theunit;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Assumptions.*;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.DisplayNameGeneration;
import org.junit.jupiter.api.DisplayNameGenerator;
import org.junit.jupiter.api.Test;

@DisplayNameGeneration(DisplayNameGenerator.Simple.class)
// @DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)
// @DisplayNameGeneration(DisplayNameGenerator.IndicativeSentences.class)
class AppTest {
	@BeforeAll
	static void initAll() {
	}

	@BeforeEach
	void init() {
	}

	@DisplayName("Test Assert Equals")
	@Test
	void testAssertEquals() {
		Double[] score = { 8.3, 4.5 };
		Double res = new App().getMedScore(score);
		final Double EXP = 6.4;
		assertEquals(EXP, res, "Falha no teste de verificação de sucesso na pontuação.");
	}

	@DisplayName("Test Assert True")
	@Test
	void testAssertTrue() {
		Double[] score = { 4.1, 5.5 };
		Double res = new App().getMedScore(score);
		final Double EXP = 4.8;
		assertTrue(EXP != res, "Falha no teste de verificação de fracasso na pontuação.");
	}

	@Test
	void testAssertInstanceOf() {
		Double[] score = { 4.7, 5.3 };
		assertInstanceOf(Long.class, new App().getMedScore(score).longValue(),
				"Falha no teste de verificação de inteiro.");
	}

	@Test
	void testAssume() {
		// Condição de execução do teste
		Double[] score = {};
		assumeFalse(score.length == 0, "Requisitos insuficientes para a execução do teste.");

		// Teste
		assertNotEquals(10.0, new App().getMedScore(score),
				"Falha no teste de verificação de valores informados.");
	}

	@Test
	void testUncaughtException() {
		new App().getMedScore(Double.valueOf("A.A"));
	}

	@Test
	void testExceptionThrows() {
		// Verifica a classe superior e subclasse
		// RuntimeException -> IllegalArgumentException -> NumberFormatException
		assertThrows(RuntimeException.class, () -> {
			new App().getMedScore(Double.valueOf("A.C"));
		}, "Falha no teste de verificação de exceção.");
	}

	@Test
	void testExceptionThrowsExactly() {
		// Somente a classe informada
		// IllegalArgumentException -> NumberFormatException
		assertThrowsExactly(IllegalArgumentException.class, () -> {
			new App().getMedScore(Double.valueOf("E.10"));
		}, "Falha no teste de verificação de exceção específica.");
	}

	@Test
	void testExceptionDoesNotThrow() {
		// SEM exceção, então OK
		assertDoesNotThrow(() -> Long.valueOf("105"),
				"Falha no teste de verificação de NÃO exceção.");
	}

	@Test
	@Disabled
	void testDisabled() {
		// Teste com resultado ERRADO, mas que NÃO será executado
		assertTrue(Integer.valueOf(1).equals(Character.valueOf('K')),
				"Falha na verificação de igualdade de valores.");
	}

	@AfterEach
	void tearDown() {
	}

	@AfterAll
	static void tearDownAll() {
	}
}
